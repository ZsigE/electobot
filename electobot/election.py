#!/usr/bin/python
"""
Electobot
by Philip Brien (http://github.com/ZsigE)

Analysis and prediction tool based on the 2010 UK General Election results

Election structure
"""

# Python imports
import os
import logging
from operator import attrgetter

# Electobot imports
import electobot.csvparser as csvparser
import electobot.utils as utils
from electobot.constants import *
from electobot.candidate import Candidate
from electobot.constituency import Constituency

# Set up logging
logger = logging.getLogger("electobot.election")

# Classes
class Election(object):
    """Master class containing all information about the election."""
    
    def __init__(self):
        """Constructor."""
        
        # Data used to run the election
        self.constituencies = {}
        self.predicted_support = {}
        
        # Data generated by running the election
        self.parties = {}
        self.swing_matrix = {}
        
        # Data generated by analyzing the results
        self.result = None
        
        return
        
    def populate_from_csv(self, csv_filename=HARVARD_CSV):
        """Create an Election from saved election data in CSV format."""
        
        # Extract all the information from the CSV file.
        rows = csvparser.csv_to_dicts(csv_filename)
        logger.debug("Found {0} rows".format(len(rows)))
           
        for row in rows:
            const = row["Seat"]
            logger.debug("Found seat {0}".format(const))
            if const not in self.constituencies:
                c = Constituency(const, self)
                self.constituencies[const] = c
            else:
                c = self.constituencies[const]
            c.region = row["Region"]
            candidates_2010 = row.candidates()
            c.votes_2005 = row.votes(2005)
            c.votes_2010 = row.votes(2010)
            c.turnout_2005 = float(row["Turn05"])
            c.turnout_2010 = float(row["Turn10"])

            # Copy the votes into the Candidate structures.
            c.candidates_2010 = []
            for party in c.votes_2010.keys():
                if party in candidates_2010.keys():
                    name = candidates_2010[party]
                else:
                    name = "Unknown"
                candidate = Candidate(name, party, c.votes_2010[party])
                c.candidates_2010.append(candidate)
                            
        return
    
    def add_total_2010_votes(self):
        """Fill in the total votes for 2010 for each constituency from the
        Guardian data and fix up the 'Other' category.
        """
        
        total_votes = csvparser.get_total_votes_from_guardian()
        
        for const_name in self.constituencies.keys():
            const = self.constituencies[const_name]
            del const.votes_2010[OTH]
            non_other_votes = sum(const.votes_2010.values())
            const.votes_2010[OTH] = total_votes[const_name] - non_other_votes
            
        return

    def prepare_predicted_support(self):
        """Do some tidy-up work on the predicted support so we can use it."""
        
        # If a party has no support recorded, remove them entirely - we'll treat
        # them as part of the "Other" pot.
        for party in self.predicted_support.keys():
            if self.predicted_support[party] == 0:
                del self.predicted_support[party]
            else:
                # Express the support as a ratio, not a percentage - this makes
                # the maths much easier.
                self.predicted_support[party] = \
                                           (self.predicted_support[party] / 100)
        
        # Fill in "Other" support automatically, to guarantee the support adds up
        # to 100.
        self.predicted_support[OTH] = (1 - sum(self.predicted_support.values()))
        
        return        
   
    def calculate_overall_support(self, year=None):
        """Create a support dictionary based on the number of votes in the
        given year.  If no year is provided, use the predicted votes.
        """
        
        total_votes = {}
        for const_name in self.constituencies.keys():
            const = self.constituencies[const_name]
            if year is None:
                votes = const.sim_votes
            elif year == 2005:
                votes = const.votes_2005
            else:
                assert year == 2010, "Year must be None, 2005 or 2010"
                votes = const.votes_2010
            for party in votes.keys():
                if party not in total_votes.keys():
                    total_votes[party] = votes[party]
                else:
                    total_votes[party] += votes[party]
        
        support = utils.calculate_support(total_votes)
                    
        return support
                
    def predict_votes(self):
        """Predict the numbers of votes in each constituency."""
        
        # Calculate the overall swing matrix.
        logger.debug("Calculating national swing matrix")
        support_2010 = self.calculate_overall_support(2010)
        self.swing_matrix = utils.calculate_swing(support_2010,
                                                  self.predicted_support)
        
        # Now use that to predict each constituency's vote distribution.
        for const_name in self.constituencies:
            const = self.constituencies[const_name]
            const.predict_votes(self.predicted_support)
            
        return
    
    def simulate(self):
        """Simulate the outcome of this election."""
        
        for const_name in self.constituencies:
            const = self.constituencies[const_name]
            const.simulate()
            
            # Add the seat to the winning party's total.
            if const.winning_party in self.parties.keys():          
                self.parties[const.winning_party].seats += 1
            else:
                party = Party(const.winning_party)
                party.seats = 1
                self.parties[const.winning_party] = party
        
        return
    
    def analyze(self):
        """Analyze the results of the election."""
        
        # Create a new Result structure to hold these results.
        self.result = Result()
        
        # First determine the largest party.
        party_list = sorted(self.parties.values(),
                            key=attrgetter('seats'),
                            reverse=True)
        self.result.largest_party = party_list[0].name
        self.result.most_seats_won = party_list[0].seats

        # Save off the numbers of seats gained by all parties.
        for party in self.parties:
            self.result.seats[party] = self.parties[party].seats
            
        # Record zero seats for any party that didn't get any.
        for party in (set(PARTY_NAMES) - set(self.parties)):
            self.result.seats[party] = 0
                
        # Now determine whether the largest party is past or behind the winning
        # line (and by how much).
        self.result.margin_of_victory = (self.result.most_seats_won - 
                                         NEEDED_FOR_MAJORITY)
        if self.result.margin_of_victory >= 0:
            self.result.summary = "{0} victory (majority {1})".format(
                                                  self.result.largest_party,
                                                  self.result.margin_of_victory)
            self.result.winner = self.result.largest_party
        else:
            self.result.summary = "Hung Parliament ({0} needs {1})".format(
                                            self.result.largest_party,
                                            (0 - self.result.margin_of_victory))
            
        # Did UKIP win any seats in this election?
        if UKP in self.parties:
            self.result.ukip_seats = self.parties[UKP].seats
        else:
            self.result.ukip_seats = 0
        
        # Did the Lib-Dems?
        if LD in self.parties:
            self.result.libdem_seats = self.parties[LD].seats
        else:
            self.result.libdem_seats = 0
        
        # Did the Greens hold Brighton Pavilion?
        if self.constituencies["Brighton Pavilion"].winning_party == GRN:
            self.result.greens_hold_brighton = True
        else:
            self.result.greens_hold_brighton = False
            
        # Was the party with the most seats the popular vote winner?
        votes = {}
        for const_name in self.constituencies:
            const = self.constituencies[const_name]
            for party in const.sim_votes.keys():
                if party not in votes.keys():
                    votes[party] = const.sim_votes[party]
                else:
                    votes[party] += const.sim_votes[party]
                    
        most_votes = 0
        self.result.most_votes_party = None
        for party in votes.keys():
            if votes[party] > most_votes:
                most_votes = votes[party]
                self.result.most_votes_party = party
                
        self.result.seat_winner_is_pop_winner = (self.result.largest_party ==
                                                 self.result.most_votes_party)
        
        # Was the vote distribution sufficiently close to the initial support
        # figures?
        overall_support = utils.calculate_support(votes)
        support_2010 = self.calculate_overall_support(2010)
        self.result.support = overall_support
        for party in self.predicted_support:
            divergence = abs(self.predicted_support[party] - 
                             overall_support[party])
            logger.debug("{0} support was {1}, predicted {2}, actual {3}, "
                         "divergence {4}".format(party,
                                                 support_2010[party],
                                                 self.predicted_support[party],
                                                 overall_support[party],
                                                 divergence))
            if divergence > RESULT_TOLERANCE:
                # This party's result is too far away from its predicted
                # support.  This result can't stand.
                logger.debug("Result too far from prediction!")
                self.result.result_too_divergent = True
        
        return
    
    def run(self):
        """Run the whole election."""
        
        self.predict_votes()
        self.simulate()
        self.analyze()
        
        return

class Party(object):
    """Political party.  Used to classify Candidates."""
    
    def __init__(self, name):
        """Constructor.  Store just the name."""
        
        self.name = name
        self.seats = 0
        
        return

class Result(object):
    """Result of the election, including all the information we might want to
    know about.
    """
    
    def __init__(self):
        """Constructor.  Initialize instance variables."""
        
        self.summary = ""  # One-line summary of the election result
        self.winner = None  # None represents a hung parliament
        self.seats = {}
        self.largest_party = None
        self.most_votes_party = None
        self.margin_of_victory = 0
        self.most_seats_won = 0
        self.ukip_seats = 0  
        self.libdem_seats = 0  
        self.greens_hold_brighton = False
        self.seat_winner_is_pop_winner = False   
        
        # Internal diagnostics
        self.support = None
        self.result_too_divergent = False